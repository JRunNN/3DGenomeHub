import {
  require_buffer
} from "./chunk-WVR4NYW2.js";
import {
  __commonJS,
  __toESM
} from "./chunk-JEXKZRFY.js";

// (disabled):node_modules/generic-filehandle/esm/localFile
var require_localFile = __commonJS({
  "(disabled):node_modules/generic-filehandle/esm/localFile"() {
  }
});

// node_modules/generic-filehandle/esm/index.js
var import_localFile = __toESM(require_localFile());

// node_modules/generic-filehandle/esm/remoteFile.js
var import_buffer = __toESM(require_buffer());
var RemoteFile = class {
  async getBufferFromResponse(response) {
    if (typeof response.buffer === "function") {
      return response.buffer();
    } else if (typeof response.arrayBuffer === "function") {
      const resp = await response.arrayBuffer();
      return import_buffer.Buffer.from(resp);
    } else {
      throw new TypeError("invalid HTTP response object, has no buffer method, and no arrayBuffer method");
    }
  }
  constructor(source, opts = {}) {
    this.baseOverrides = {};
    this.url = source;
    const fetch = opts.fetch || globalThis.fetch.bind(globalThis);
    if (!fetch) {
      throw new TypeError(`no fetch function supplied, and none found in global environment`);
    }
    if (opts.overrides) {
      this.baseOverrides = opts.overrides;
    }
    this.fetchImplementation = fetch;
  }
  async fetch(input, init) {
    let response;
    try {
      response = await this.fetchImplementation(input, init);
    } catch (e) {
      if (`${e}`.includes("Failed to fetch")) {
        console.warn(`generic-filehandle: refetching ${input} to attempt to work around chrome CORS header caching bug`);
        response = await this.fetchImplementation(input, {
          ...init,
          cache: "reload"
        });
      } else {
        throw e;
      }
    }
    return response;
  }
  async read(buffer, offset = 0, length, position = 0, opts = {}) {
    const { headers = {}, signal, overrides = {} } = opts;
    if (length < Infinity) {
      headers.range = `bytes=${position}-${position + length}`;
    } else if (length === Infinity && position !== 0) {
      headers.range = `bytes=${position}-`;
    }
    const args = {
      ...this.baseOverrides,
      ...overrides,
      headers: {
        ...headers,
        ...overrides.headers,
        ...this.baseOverrides.headers
      },
      method: "GET",
      redirect: "follow",
      mode: "cors",
      signal
    };
    const response = await this.fetch(this.url, args);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} ${response.statusText} ${this.url}`);
    }
    if (response.status === 200 && position === 0 || response.status === 206) {
      const responseData = await this.getBufferFromResponse(response);
      const bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length));
      const res = response.headers.get("content-range");
      const sizeMatch = /\/(\d+)$/.exec(res || "");
      if (sizeMatch && sizeMatch[1]) {
        this._stat = { size: parseInt(sizeMatch[1], 10) };
      }
      return { bytesRead: bytesCopied, buffer };
    }
    if (response.status === 200) {
      throw new Error("${this.url} fetch returned status 200, expected 206");
    }
    throw new Error(`HTTP ${response.status} fetching ${this.url}`);
  }
  async readFile(options = {}) {
    let encoding;
    let opts;
    if (typeof options === "string") {
      encoding = options;
      opts = {};
    } else {
      encoding = options.encoding;
      opts = options;
      delete opts.encoding;
    }
    const { headers = {}, signal, overrides = {} } = opts;
    const args = {
      headers,
      method: "GET",
      redirect: "follow",
      mode: "cors",
      signal,
      ...this.baseOverrides,
      ...overrides
    };
    const response = await this.fetch(this.url, args);
    if (!response) {
      throw new Error("generic-filehandle failed to fetch");
    }
    if (response.status !== 200) {
      throw Object.assign(new Error(`HTTP ${response.status} fetching ${this.url}`), {
        status: response.status
      });
    }
    if (encoding === "utf8") {
      return response.text();
    }
    if (encoding) {
      throw new Error(`unsupported encoding: ${encoding}`);
    }
    return this.getBufferFromResponse(response);
  }
  async stat() {
    if (!this._stat) {
      const buf = import_buffer.Buffer.allocUnsafe(10);
      await this.read(buf, 0, 10, 0);
      if (!this._stat) {
        throw new Error(`unable to determine size of file at ${this.url}`);
      }
    }
    return this._stat;
  }
  async close() {
    return;
  }
};

// node_modules/generic-filehandle/esm/blobFile.js
var import_buffer2 = __toESM(require_buffer());
function readBlobAsArrayBuffer(blob) {
  const fileReader = new FileReader();
  return new Promise((resolve, reject) => {
    fileReader.onerror = () => {
      fileReader.abort();
      reject(new Error("problem reading blob"));
    };
    fileReader.onabort = () => {
      reject(new Error("blob reading was aborted"));
    };
    fileReader.onload = () => {
      if (fileReader.result && typeof fileReader.result !== "string") {
        resolve(fileReader.result);
      } else {
        reject(new Error("unknown error reading blob"));
      }
    };
    fileReader.readAsArrayBuffer(blob);
  });
}
function readBlobAsText(blob) {
  const fileReader = new FileReader();
  return new Promise((resolve, reject) => {
    fileReader.onerror = () => {
      fileReader.abort();
      reject(new Error("problem reading blob"));
    };
    fileReader.onabort = () => {
      reject(new Error("blob reading was aborted"));
    };
    fileReader.onload = () => {
      if (fileReader.result && typeof fileReader.result === "string") {
        resolve(fileReader.result);
      } else {
        reject(new Error("unknown error reading blob"));
      }
    };
    fileReader.readAsText(blob);
  });
}
var BlobFile = class {
  constructor(blob) {
    this.blob = blob;
    this.size = blob.size;
  }
  async read(buffer, offset = 0, length, position = 0) {
    if (!length) {
      return { bytesRead: 0, buffer };
    }
    const start = position;
    const end = start + length;
    const result = await readBlobAsArrayBuffer(this.blob.slice(start, end));
    const resultBuffer = import_buffer2.Buffer.from(result);
    const bytesCopied = resultBuffer.copy(buffer, offset);
    return { bytesRead: bytesCopied, buffer: resultBuffer };
  }
  async readFile(options) {
    let encoding;
    if (typeof options === "string") {
      encoding = options;
    } else {
      encoding = options && options.encoding;
    }
    if (encoding === "utf8") {
      return readBlobAsText(this.blob);
    }
    if (encoding) {
      throw new Error(`unsupported encoding: ${encoding}`);
    }
    const result = await readBlobAsArrayBuffer(this.blob);
    return import_buffer2.Buffer.from(result);
  }
  async stat() {
    return { size: this.size };
  }
  async close() {
    return;
  }
};

// node_modules/generic-filehandle/esm/index.js
function fromUrl(source, opts = {}) {
  return new RemoteFile(source, opts);
}
function open(maybeUrl, maybePath, maybeFilehandle, opts = {}) {
  if (maybeFilehandle !== void 0) {
    return maybeFilehandle;
  }
  if (maybeUrl !== void 0) {
    return fromUrl(maybeUrl, opts);
  }
  if (maybePath !== void 0) {
    return new import_localFile.default(maybePath, opts);
  }
  throw new Error("no url, path, or filehandle provided, cannot open");
}

export {
  RemoteFile,
  BlobFile,
  import_localFile,
  fromUrl,
  open
};
//# sourceMappingURL=chunk-SCS3ED4A.js.map
