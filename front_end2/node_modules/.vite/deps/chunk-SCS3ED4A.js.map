{
  "version": 3,
  "sources": ["../../generic-filehandle/src/index.ts", "../../generic-filehandle/src/remoteFile.ts", "../../generic-filehandle/src/blobFile.ts"],
  "sourcesContent": ["import LocalFile from './localFile'\nimport RemoteFile from './remoteFile'\nimport BlobFile from './blobFile'\nimport { GenericFilehandle, FilehandleOptions } from './filehandle'\nexport * from './filehandle'\n\nfunction fromUrl(\n  source: string,\n  opts: FilehandleOptions = {},\n): GenericFilehandle {\n  return new RemoteFile(source, opts)\n}\nfunction open(\n  maybeUrl?: string,\n  maybePath?: string,\n  maybeFilehandle?: GenericFilehandle,\n  opts: FilehandleOptions = {},\n): GenericFilehandle {\n  if (maybeFilehandle !== undefined) {\n    return maybeFilehandle\n  }\n  if (maybeUrl !== undefined) {\n    return fromUrl(maybeUrl, opts)\n  }\n  if (maybePath !== undefined) {\n    return new LocalFile(maybePath, opts)\n  }\n  throw new Error('no url, path, or filehandle provided, cannot open')\n}\n\nexport { open, fromUrl, RemoteFile, LocalFile, BlobFile }\n", "import { Buffer } from 'buffer'\nimport {\n  GenericFilehandle,\n  FilehandleOptions,\n  Stats,\n  Fetcher,\n  PolyfilledResponse,\n} from './filehandle'\n\nexport default class RemoteFile implements GenericFilehandle {\n  protected url: string\n  private _stat?: Stats\n  private fetchImplementation: Fetcher\n  private baseOverrides: any = {}\n\n  private async getBufferFromResponse(\n    response: PolyfilledResponse,\n  ): Promise<Buffer> {\n    if (typeof response.buffer === 'function') {\n      return response.buffer()\n    } else if (typeof response.arrayBuffer === 'function') {\n      const resp = await response.arrayBuffer()\n      return Buffer.from(resp)\n    } else {\n      throw new TypeError(\n        'invalid HTTP response object, has no buffer method, and no arrayBuffer method',\n      )\n    }\n  }\n\n  public constructor(source: string, opts: FilehandleOptions = {}) {\n    this.url = source\n    const fetch = opts.fetch || globalThis.fetch.bind(globalThis)\n    if (!fetch) {\n      throw new TypeError(\n        `no fetch function supplied, and none found in global environment`,\n      )\n    }\n    if (opts.overrides) {\n      this.baseOverrides = opts.overrides\n    }\n    this.fetchImplementation = fetch\n  }\n\n  public async fetch(\n    input: RequestInfo,\n    init: RequestInit | undefined,\n  ): Promise<PolyfilledResponse> {\n    let response\n    try {\n      response = await this.fetchImplementation(input, init)\n    } catch (e) {\n      if (`${e}`.includes('Failed to fetch')) {\n        // refetch to to help work around a chrome bug (discussed in\n        // generic-filehandle issue #72) in which the chrome cache returns a\n        // CORS error for content in its cache.  see also\n        // https://github.com/GMOD/jbrowse-components/pull/1511\n        console.warn(\n          `generic-filehandle: refetching ${input} to attempt to work around chrome CORS header caching bug`,\n        )\n        response = await this.fetchImplementation(input, {\n          ...init,\n          cache: 'reload',\n        })\n      } else {\n        throw e\n      }\n    }\n    return response\n  }\n\n  public async read(\n    buffer: Buffer,\n    offset = 0,\n    length: number,\n    position = 0,\n    opts: FilehandleOptions = {},\n  ): Promise<{ bytesRead: number; buffer: Buffer }> {\n    const { headers = {}, signal, overrides = {} } = opts\n    if (length < Infinity) {\n      headers.range = `bytes=${position}-${position + length}`\n    } else if (length === Infinity && position !== 0) {\n      headers.range = `bytes=${position}-`\n    }\n    const args = {\n      ...this.baseOverrides,\n      ...overrides,\n      headers: {\n        ...headers,\n        ...overrides.headers,\n        ...this.baseOverrides.headers,\n      },\n      method: 'GET',\n      redirect: 'follow',\n      mode: 'cors',\n      signal,\n    }\n    const response = await this.fetch(this.url, args)\n\n    if (!response.ok) {\n      throw new Error(\n        `HTTP ${response.status} ${response.statusText} ${this.url}`,\n      )\n    }\n\n    if (\n      (response.status === 200 && position === 0) ||\n      response.status === 206\n    ) {\n      const responseData = await this.getBufferFromResponse(response)\n      const bytesCopied = responseData.copy(\n        buffer,\n        offset,\n        0,\n        Math.min(length, responseData.length),\n      )\n\n      // try to parse out the size of the remote file\n      const res = response.headers.get('content-range')\n      const sizeMatch = /\\/(\\d+)$/.exec(res || '')\n      if (sizeMatch && sizeMatch[1]) {\n        this._stat = { size: parseInt(sizeMatch[1], 10) }\n      }\n\n      return { bytesRead: bytesCopied, buffer }\n    }\n\n    if (response.status === 200) {\n      throw new Error('${this.url} fetch returned status 200, expected 206')\n    }\n\n    // TODO: try harder here to gather more information about what the problem is\n    throw new Error(`HTTP ${response.status} fetching ${this.url}`)\n  }\n\n  public async readFile(): Promise<Buffer>\n  public async readFile(options: BufferEncoding): Promise<string>\n  public async readFile<T extends undefined>(\n    options:\n      | Omit<FilehandleOptions, 'encoding'>\n      | (Omit<FilehandleOptions, 'encoding'> & { encoding: T }),\n  ): Promise<Buffer>\n  public async readFile<T extends BufferEncoding>(\n    options: Omit<FilehandleOptions, 'encoding'> & { encoding: T },\n  ): Promise<string>\n  readFile<T extends BufferEncoding>(\n    options: Omit<FilehandleOptions, 'encoding'> & { encoding: T },\n  ): T extends BufferEncoding ? Promise<Buffer> : Promise<Buffer | string>\n  public async readFile(\n    options: FilehandleOptions | BufferEncoding = {},\n  ): Promise<Buffer | string> {\n    let encoding\n    let opts\n    if (typeof options === 'string') {\n      encoding = options\n      opts = {}\n    } else {\n      encoding = options.encoding\n      opts = options\n      delete opts.encoding\n    }\n    const { headers = {}, signal, overrides = {} } = opts\n    const args = {\n      headers,\n      method: 'GET',\n      redirect: 'follow',\n      mode: 'cors',\n      signal,\n      ...this.baseOverrides,\n      ...overrides,\n    }\n    const response = await this.fetch(this.url, args)\n\n    if (!response) {\n      throw new Error('generic-filehandle failed to fetch')\n    }\n\n    if (response.status !== 200) {\n      throw Object.assign(\n        new Error(`HTTP ${response.status} fetching ${this.url}`),\n        {\n          status: response.status,\n        },\n      )\n    }\n    if (encoding === 'utf8') {\n      return response.text()\n    }\n    if (encoding) {\n      throw new Error(`unsupported encoding: ${encoding}`)\n    }\n    return this.getBufferFromResponse(response)\n  }\n\n  public async stat(): Promise<Stats> {\n    if (!this._stat) {\n      const buf = Buffer.allocUnsafe(10)\n      await this.read(buf, 0, 10, 0)\n      if (!this._stat) {\n        throw new Error(`unable to determine size of file at ${this.url}`)\n      }\n    }\n    return this._stat\n  }\n\n  public async close(): Promise<void> {\n    return\n  }\n}\n", "import { Buffer } from 'buffer'\nimport { GenericFilehandle, FilehandleOptions, Stats } from './filehandle'\n\n// Using this you can \"await\" the file like a normal promise\n// https://blog.shovonhasan.com/using-promises-with-filereader/\nfunction readBlobAsArrayBuffer(blob: Blob): Promise<ArrayBuffer> {\n  const fileReader = new FileReader()\n\n  return new Promise((resolve, reject): void => {\n    fileReader.onerror = (): void => {\n      fileReader.abort()\n      reject(new Error('problem reading blob'))\n    }\n\n    fileReader.onabort = (): void => {\n      reject(new Error('blob reading was aborted'))\n    }\n\n    fileReader.onload = (): void => {\n      if (fileReader.result && typeof fileReader.result !== 'string') {\n        resolve(fileReader.result)\n      } else {\n        reject(new Error('unknown error reading blob'))\n      }\n    }\n    fileReader.readAsArrayBuffer(blob)\n  })\n}\n\nfunction readBlobAsText(blob: Blob): Promise<string> {\n  const fileReader = new FileReader()\n\n  return new Promise((resolve, reject): void => {\n    fileReader.onerror = (): void => {\n      fileReader.abort()\n      reject(new Error('problem reading blob'))\n    }\n\n    fileReader.onabort = (): void => {\n      reject(new Error('blob reading was aborted'))\n    }\n\n    fileReader.onload = (): void => {\n      if (fileReader.result && typeof fileReader.result === 'string') {\n        resolve(fileReader.result)\n      } else {\n        reject(new Error('unknown error reading blob'))\n      }\n    }\n    fileReader.readAsText(blob)\n  })\n}\n\n/**\n * Blob of binary data fetched from a local file (with FileReader).\n *\n * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in\n * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.\n */\nexport default class BlobFile implements GenericFilehandle {\n  private blob: Blob\n  private size: number\n  public constructor(blob: Blob) {\n    this.blob = blob\n    this.size = blob.size\n  }\n\n  public async read(\n    buffer: Buffer,\n    offset = 0,\n    length: number,\n    position = 0,\n  ): Promise<{ bytesRead: number; buffer: Buffer }> {\n    // short-circuit a read of 0 bytes here, because browsers actually sometimes\n    // crash if you try to read 0 bytes from a local file!\n    if (!length) {\n      return { bytesRead: 0, buffer }\n    }\n\n    const start = position\n    const end = start + length\n\n    const result = await readBlobAsArrayBuffer(this.blob.slice(start, end))\n    const resultBuffer = Buffer.from(result)\n\n    const bytesCopied = resultBuffer.copy(buffer, offset)\n\n    return { bytesRead: bytesCopied, buffer: resultBuffer }\n  }\n\n  public async readFile(): Promise<Buffer>\n  public async readFile(options: BufferEncoding): Promise<string>\n  public async readFile<T extends undefined>(\n    options:\n      | Omit<FilehandleOptions, 'encoding'>\n      | (Omit<FilehandleOptions, 'encoding'> & { encoding: T }),\n  ): Promise<Buffer>\n  public async readFile<T extends BufferEncoding>(\n    options: Omit<FilehandleOptions, 'encoding'> & { encoding: T },\n  ): Promise<string>\n  public async readFile(\n    options?: FilehandleOptions | BufferEncoding,\n  ): Promise<Buffer | string> {\n    let encoding\n    if (typeof options === 'string') {\n      encoding = options\n    } else {\n      encoding = options && options.encoding\n    }\n    if (encoding === 'utf8') {\n      return readBlobAsText(this.blob)\n    }\n    if (encoding) {\n      throw new Error(`unsupported encoding: ${encoding}`)\n    }\n    const result = await readBlobAsArrayBuffer(this.blob)\n    return Buffer.from(result)\n  }\n\n  public async stat(): Promise<Stats> {\n    return { size: this.size }\n  }\n\n  public async close(): Promise<void> {\n    return\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_buffer", "LocalFile"]
}
