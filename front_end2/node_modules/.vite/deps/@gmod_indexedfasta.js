import {
  BgzFilehandle
} from "./chunk-6OABXZX4.js";
import {
  import_localFile
} from "./chunk-SCS3ED4A.js";
import "./chunk-WVR4NYW2.js";
import "./chunk-JEXKZRFY.js";

// node_modules/@gmod/indexedfasta/esm/indexedFasta.js
function _faiOffset(idx, pos) {
  return idx.offset + idx.lineBytes * Math.floor(pos / idx.lineLength) + pos % idx.lineLength;
}
async function readFAI(fai, opts) {
  const text = await fai.readFile(opts);
  if (!(text && text.length)) {
    throw new Error("No data read from FASTA index (FAI) file");
  }
  let idCounter = 0;
  let currSeq;
  const data = text.toString("utf8").split(/\r?\n/).filter((line) => /\S/.test(line)).map((line) => line.split("	")).filter((row) => row[0] !== "").map((row) => {
    if (!currSeq || currSeq.name !== row[0]) {
      currSeq = { name: row[0], id: idCounter };
      idCounter += 1;
    }
    return {
      id: currSeq.id,
      name: row[0],
      length: +row[1],
      start: 0,
      end: +row[1],
      offset: +row[2],
      lineLength: +row[3],
      lineBytes: +row[4]
    };
  });
  return {
    name: Object.fromEntries(data.map((entry) => [entry.name, entry])),
    id: Object.fromEntries(data.map((entry) => [entry.id, entry]))
  };
}
var IndexedFasta = class {
  constructor({ fasta, fai, path, faiPath }) {
    if (fasta) {
      this.fasta = fasta;
    } else if (path) {
      this.fasta = new import_localFile.default(path);
    } else {
      throw new Error("Need to pass filehandle for fasta or path to localfile");
    }
    if (fai) {
      this.fai = fai;
    } else if (faiPath) {
      this.fai = new import_localFile.default(faiPath);
    } else if (path) {
      this.fai = new import_localFile.default(`${path}.fai`);
    } else {
      throw new Error("Need to pass filehandle for  or path to localfile");
    }
  }
  async _getIndexes(opts) {
    if (!this.indexes) {
      this.indexes = readFAI(this.fai, opts);
    }
    return this.indexes;
  }
  /**
   * @returns {array[string]} array of string sequence
   * names that are present in the index, in which the
   * array index indicates the sequence ID, and the value
   * is the sequence name
   */
  async getSequenceNames(opts) {
    return Object.keys((await this._getIndexes(opts)).name);
  }
  /**
   * @returns {array[string]} array of string sequence
   * names that are present in the index, in which the
   * array index indicates the sequence ID, and the value
   * is the sequence name
   */
  async getSequenceSizes(opts) {
    const returnObject = {};
    const idx = await this._getIndexes(opts);
    const vals = Object.values(idx.id);
    for (let i = 0; i < vals.length; i += 1) {
      returnObject[vals[i].name] = vals[i].length;
    }
    return returnObject;
  }
  /**
   * @returns {array[string]} array of string sequence
   * names that are present in the index, in which the
   * array index indicates the sequence ID, and the value
   * is the sequence name
   */
  async getSequenceSize(seqName, opts) {
    var _a;
    const idx = await this._getIndexes(opts);
    return (_a = idx.name[seqName]) === null || _a === void 0 ? void 0 : _a.length;
  }
  /**
   *
   * @param {string} name
   * @returns {Promise[boolean]} true if the file contains the given reference sequence name
   */
  async hasReferenceSequence(name, opts) {
    return !!(await this._getIndexes(opts)).name[name];
  }
  /**
   *
   * @param {number} seqId
   * @param {number} min
   * @param {number} max
   */
  async getResiduesById(seqId, min, max, opts) {
    const indexEntry = (await this._getIndexes(opts)).id[seqId];
    if (!indexEntry) {
      return void 0;
    }
    return this._fetchFromIndexEntry(indexEntry, min, max, opts);
  }
  /**
   * @param {string} seqName
   * @param {number} min
   * @param {number} max
   */
  async getResiduesByName(seqName, min, max, opts) {
    const indexEntry = (await this._getIndexes(opts)).name[seqName];
    if (!indexEntry) {
      return void 0;
    }
    return this._fetchFromIndexEntry(indexEntry, min, max, opts);
  }
  //alias for getResiduesByName
  async getSequence(seqName, min, max, opts) {
    return this.getResiduesByName(seqName, min, max, opts);
  }
  async _fetchFromIndexEntry(indexEntry, min = 0, max, opts) {
    let end = max;
    if (min < 0) {
      throw new TypeError("regionStart cannot be less than 0");
    }
    if (end === void 0 || end > indexEntry.length) {
      end = indexEntry.length;
    }
    if (min >= end) {
      return "";
    }
    const position = _faiOffset(indexEntry, min);
    const readlen = _faiOffset(indexEntry, end) - position;
    const residues = Buffer.allocUnsafe(readlen);
    await this.fasta.read(residues, 0, readlen, position, opts);
    return residues.toString("utf8").replace(/\s+/g, "");
  }
};

// node_modules/@gmod/indexedfasta/esm/bgzipIndexedFasta.js
var BgzipIndexedFasta = class extends IndexedFasta {
  constructor({ fasta, path, fai, faiPath, gzi, gziPath }) {
    super({ fasta, path, fai, faiPath });
    if (fasta && gzi) {
      this.fasta = new BgzFilehandle({
        filehandle: fasta,
        gziFilehandle: gzi
      });
    } else if (path && gziPath) {
      this.fasta = new BgzFilehandle({ path, gziPath });
    }
  }
};

// node_modules/@gmod/indexedfasta/esm/index.js
function parseSmallFasta(text) {
  return text.split(">").filter((t) => /\S/.test(t)).map((entryText) => {
    const [defLine, ...seqLines] = entryText.split("\n");
    const [id, ...description] = defLine.split(" ");
    const sequence = seqLines.join("").replace(/\s/g, "");
    return {
      id,
      description: description.join(" "),
      sequence
    };
  });
}
var FetchableSmallFasta = class {
  constructor({ fasta, path }) {
    if (fasta) {
      this.fasta = fasta;
    } else if (path) {
      this.fasta = new import_localFile.default(path);
    } else {
      throw new Error("Need to pass fasta or path");
    }
    this.data = this.fasta.readFile().then((buffer) => {
      const text = buffer.toString("utf8");
      return parseSmallFasta(text);
    });
  }
  async fetch(id, start, end) {
    const data = await this.data;
    const entry = data.find((iter) => iter.id === id);
    const length = end - start;
    if (!entry) {
      throw new Error(`no sequence with id ${id} exists`);
    }
    return entry.sequence.substr(start, length);
  }
  async getSequenceNames() {
    const data = await this.data;
    return data.map((entry) => entry.id);
  }
};
export {
  BgzipIndexedFasta,
  FetchableSmallFasta,
  IndexedFasta,
  parseSmallFasta
};
//# sourceMappingURL=@gmod_indexedfasta.js.map
