{
  "version": 3,
  "sources": ["../../@gmod/indexedfasta/src/indexedFasta.ts", "../../@gmod/indexedfasta/src/bgzipIndexedFasta.ts", "../../@gmod/indexedfasta/src/index.ts"],
  "sourcesContent": ["import { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\ninterface BaseOpts {\n  signal?: AbortSignal\n}\n\ninterface IndexEntry {\n  offset: number\n  lineBytes: number\n  lineLength: number\n  length: number\n}\n\nfunction _faiOffset(idx: IndexEntry, pos: number) {\n  return (\n    idx.offset +\n    idx.lineBytes * Math.floor(pos / idx.lineLength) +\n    (pos % idx.lineLength)\n  )\n}\n\nasync function readFAI(fai: GenericFilehandle, opts?: BaseOpts) {\n  const text = await fai.readFile(opts)\n  if (!(text && text.length)) {\n    throw new Error('No data read from FASTA index (FAI) file')\n  }\n\n  let idCounter = 0\n  let currSeq: { name: string; id: number } | undefined\n  const data = text\n    .toString('utf8')\n    .split(/\\r?\\n/)\n    .filter(line => /\\S/.test(line))\n    .map(line => line.split('\\t'))\n    .filter(row => row[0] !== '')\n    .map(row => {\n      if (!currSeq || currSeq.name !== row[0]) {\n        currSeq = { name: row[0], id: idCounter }\n        idCounter += 1\n      }\n\n      return {\n        id: currSeq.id,\n        name: row[0],\n        length: +row[1],\n        start: 0,\n        end: +row[1],\n        offset: +row[2],\n        lineLength: +row[3],\n        lineBytes: +row[4],\n      }\n    })\n\n  return {\n    name: Object.fromEntries(data.map(entry => [entry.name, entry])),\n    id: Object.fromEntries(data.map(entry => [entry.id, entry])),\n  }\n}\n\nexport default class IndexedFasta {\n  fasta: GenericFilehandle\n  fai: GenericFilehandle\n  indexes?: ReturnType<typeof readFAI>\n\n  constructor({\n    fasta,\n    fai,\n    path,\n    faiPath,\n  }: {\n    fasta?: GenericFilehandle\n    fai?: GenericFilehandle\n    path?: string\n    faiPath?: string\n  }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass filehandle for fasta or path to localfile')\n    }\n\n    if (fai) {\n      this.fai = fai\n    } else if (faiPath) {\n      this.fai = new LocalFile(faiPath)\n    } else if (path) {\n      this.fai = new LocalFile(`${path}.fai`)\n    } else {\n      throw new Error('Need to pass filehandle for  or path to localfile')\n    }\n  }\n\n  async _getIndexes(opts?: BaseOpts) {\n    if (!this.indexes) {\n      this.indexes = readFAI(this.fai, opts)\n    }\n    return this.indexes\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceNames(opts?: BaseOpts) {\n    return Object.keys((await this._getIndexes(opts)).name)\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSizes(opts?: BaseOpts) {\n    const returnObject = {} as { [key: string]: number }\n    const idx = await this._getIndexes(opts)\n    const vals = Object.values(idx.id)\n    for (let i = 0; i < vals.length; i += 1) {\n      returnObject[vals[i].name] = vals[i].length\n    }\n    return returnObject\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSize(seqName: string, opts?: BaseOpts) {\n    const idx = await this._getIndexes(opts)\n    return idx.name[seqName]?.length\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @returns {Promise[boolean]} true if the file contains the given reference sequence name\n   */\n  async hasReferenceSequence(name: string, opts?: BaseOpts) {\n    return !!(await this._getIndexes(opts)).name[name]\n  }\n\n  /**\n   *\n   * @param {number} seqId\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesById(\n    seqId: number,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).id[seqId]\n    if (!indexEntry) {\n      return undefined\n    }\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  /**\n   * @param {string} seqName\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesByName(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).name[seqName]\n    if (!indexEntry) {\n      return undefined\n    }\n\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  //alias for getResiduesByName\n  async getSequence(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    return this.getResiduesByName(seqName, min, max, opts)\n  }\n\n  async _fetchFromIndexEntry(\n    indexEntry: IndexEntry,\n    min = 0,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    let end = max\n    if (min < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    if (end === undefined || end > indexEntry.length) {\n      end = indexEntry.length\n    }\n    if (min >= end) {\n      return ''\n    }\n\n    const position = _faiOffset(indexEntry, min)\n    const readlen = _faiOffset(indexEntry, end) - position\n\n    const residues = Buffer.allocUnsafe(readlen)\n    await this.fasta.read(residues, 0, readlen, position, opts)\n    return residues.toString('utf8').replace(/\\s+/g, '')\n  }\n}\n", "import { BgzfFilehandle } from '@gmod/bgzf-filehandle'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport IndexedFasta from './indexedFasta'\n\nexport default class BgzipIndexedFasta extends IndexedFasta {\n  constructor({\n    fasta,\n    path,\n    fai,\n    faiPath,\n    gzi,\n    gziPath,\n  }: {\n    fasta?: GenericFilehandle\n    path?: string\n    fai?: GenericFilehandle\n    faiPath?: string\n    gzi?: GenericFilehandle\n    gziPath?: string\n  }) {\n    super({ fasta, path, fai, faiPath })\n    if (fasta && gzi) {\n      this.fasta = new BgzfFilehandle({\n        filehandle: fasta,\n        gziFilehandle: gzi,\n      })\n    } else if (path && gziPath) {\n      this.fasta = new BgzfFilehandle({ path, gziPath })\n    }\n  }\n}\n", "import { LocalFile, GenericFilehandle } from 'generic-filehandle'\nimport BgzipIndexedFasta from './bgzipIndexedFasta'\nimport IndexedFasta from './indexedFasta'\n\nfunction parseSmallFasta(text: string) {\n  return text\n    .split('>')\n    .filter(t => /\\S/.test(t))\n    .map(entryText => {\n      const [defLine, ...seqLines] = entryText.split('\\n')\n      const [id, ...description] = defLine.split(' ')\n      const sequence = seqLines.join('').replace(/\\s/g, '')\n      return {\n        id,\n        description: description.join(' '),\n        sequence,\n      }\n    })\n}\n\n// memoized\nclass FetchableSmallFasta {\n  fasta: GenericFilehandle\n\n  data: Promise<{ id: string; description: string; sequence: string }[]>\n\n  constructor({ fasta, path }: { fasta: GenericFilehandle; path: string }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass fasta or path')\n    }\n    this.data = this.fasta.readFile().then(buffer => {\n      const text = buffer.toString('utf8')\n      return parseSmallFasta(text)\n    })\n  }\n\n  async fetch(id: string, start: number, end: number) {\n    const data = await this.data\n    const entry = data.find(iter => iter.id === id)\n    const length = end - start\n    if (!entry) {\n      throw new Error(`no sequence with id ${id} exists`)\n    }\n    return entry.sequence.substr(start, length)\n  }\n\n  async getSequenceNames() {\n    const data = await this.data\n    return data.map(entry => entry.id)\n  }\n}\n\nexport { parseSmallFasta, FetchableSmallFasta, IndexedFasta, BgzipIndexedFasta }\n"],
  "mappings": "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",
  "names": ["LocalFile", "LocalFile"]
}
