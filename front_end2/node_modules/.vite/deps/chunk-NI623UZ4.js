import {
  __commonJS
} from "./chunk-JEXKZRFY.js";

// node_modules/abortcontroller-polyfill/dist/cjs-ponyfill.js
var require_cjs_ponyfill = __commonJS({
  "node_modules/abortcontroller-polyfill/dist/cjs-ponyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get.bind();
      } else {
        _get = function _get2(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    var Emitter = function() {
      function Emitter2() {
        _classCallCheck(this, Emitter2);
        Object.defineProperty(this, "listeners", {
          value: {},
          writable: true,
          configurable: true
        });
      }
      _createClass(Emitter2, [{
        key: "addEventListener",
        value: function addEventListener(type, callback, options) {
          if (!(type in this.listeners)) {
            this.listeners[type] = [];
          }
          this.listeners[type].push({
            callback,
            options
          });
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener(type, callback) {
          if (!(type in this.listeners)) {
            return;
          }
          var stack = this.listeners[type];
          for (var i = 0, l = stack.length; i < l; i++) {
            if (stack[i].callback === callback) {
              stack.splice(i, 1);
              return;
            }
          }
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          if (!(event.type in this.listeners)) {
            return;
          }
          var stack = this.listeners[event.type];
          var stackToCall = stack.slice();
          for (var i = 0, l = stackToCall.length; i < l; i++) {
            var listener = stackToCall[i];
            try {
              listener.callback.call(this, event);
            } catch (e) {
              Promise.resolve().then(function() {
                throw e;
              });
            }
            if (listener.options && listener.options.once) {
              this.removeEventListener(event.type, listener.callback);
            }
          }
          return !event.defaultPrevented;
        }
      }]);
      return Emitter2;
    }();
    var AbortSignal = function(_Emitter) {
      _inherits(AbortSignal2, _Emitter);
      var _super = _createSuper(AbortSignal2);
      function AbortSignal2() {
        var _this;
        _classCallCheck(this, AbortSignal2);
        _this = _super.call(this);
        if (!_this.listeners) {
          Emitter.call(_assertThisInitialized(_this));
        }
        Object.defineProperty(_assertThisInitialized(_this), "aborted", {
          value: false,
          writable: true,
          configurable: true
        });
        Object.defineProperty(_assertThisInitialized(_this), "onabort", {
          value: null,
          writable: true,
          configurable: true
        });
        Object.defineProperty(_assertThisInitialized(_this), "reason", {
          value: void 0,
          writable: true,
          configurable: true
        });
        return _this;
      }
      _createClass(AbortSignal2, [{
        key: "toString",
        value: function toString() {
          return "[object AbortSignal]";
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          if (event.type === "abort") {
            this.aborted = true;
            if (typeof this.onabort === "function") {
              this.onabort.call(this, event);
            }
          }
          _get(_getPrototypeOf(AbortSignal2.prototype), "dispatchEvent", this).call(this, event);
        }
      }]);
      return AbortSignal2;
    }(Emitter);
    var AbortController = function() {
      function AbortController2() {
        _classCallCheck(this, AbortController2);
        Object.defineProperty(this, "signal", {
          value: new AbortSignal(),
          writable: true,
          configurable: true
        });
      }
      _createClass(AbortController2, [{
        key: "abort",
        value: function abort(reason) {
          var event;
          try {
            event = new Event("abort");
          } catch (e) {
            if (typeof document !== "undefined") {
              if (!document.createEvent) {
                event = document.createEventObject();
                event.type = "abort";
              } else {
                event = document.createEvent("Event");
                event.initEvent("abort", false, false);
              }
            } else {
              event = {
                type: "abort",
                bubbles: false,
                cancelable: false
              };
            }
          }
          var signalReason = reason;
          if (signalReason === void 0) {
            if (typeof document === "undefined") {
              signalReason = new Error("This operation was aborted");
              signalReason.name = "AbortError";
            } else {
              try {
                signalReason = new DOMException("signal is aborted without reason");
              } catch (err) {
                signalReason = new Error("This operation was aborted");
                signalReason.name = "AbortError";
              }
            }
          }
          this.signal.reason = signalReason;
          this.signal.dispatchEvent(event);
        }
      }, {
        key: "toString",
        value: function toString() {
          return "[object AbortController]";
        }
      }]);
      return AbortController2;
    }();
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      AbortController.prototype[Symbol.toStringTag] = "AbortController";
      AbortSignal.prototype[Symbol.toStringTag] = "AbortSignal";
    }
    function polyfillNeeded(self2) {
      if (self2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
        console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
        return true;
      }
      return typeof self2.Request === "function" && !self2.Request.prototype.hasOwnProperty("signal") || !self2.AbortController;
    }
    function abortableFetchDecorator(patchTargets) {
      if ("function" === typeof patchTargets) {
        patchTargets = {
          fetch: patchTargets
        };
      }
      var _patchTargets = patchTargets, fetch = _patchTargets.fetch, _patchTargets$Request = _patchTargets.Request, NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request, NativeAbortController = _patchTargets.AbortController, _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL, __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;
      if (!polyfillNeeded({
        fetch,
        Request: NativeRequest,
        AbortController: NativeAbortController,
        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
      })) {
        return {
          fetch,
          Request
        };
      }
      var Request = NativeRequest;
      if (Request && !Request.prototype.hasOwnProperty("signal") || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
        Request = function Request2(input, init) {
          var signal;
          if (init && init.signal) {
            signal = init.signal;
            delete init.signal;
          }
          var request = new NativeRequest(input, init);
          if (signal) {
            Object.defineProperty(request, "signal", {
              writable: false,
              enumerable: false,
              configurable: true,
              value: signal
            });
          }
          return request;
        };
        Request.prototype = NativeRequest.prototype;
      }
      var realFetch = fetch;
      var abortableFetch = function abortableFetch2(input, init) {
        var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : void 0;
        if (signal) {
          var abortError;
          try {
            abortError = new DOMException("Aborted", "AbortError");
          } catch (err) {
            abortError = new Error("Aborted");
            abortError.name = "AbortError";
          }
          if (signal.aborted) {
            return Promise.reject(abortError);
          }
          var cancellation = new Promise(function(_, reject) {
            signal.addEventListener("abort", function() {
              return reject(abortError);
            }, {
              once: true
            });
          });
          if (init && init.signal) {
            delete init.signal;
          }
          return Promise.race([cancellation, realFetch(input, init)]);
        }
        return realFetch(input, init);
      };
      return {
        fetch: abortableFetch,
        Request
      };
    }
    exports.AbortController = AbortController;
    exports.AbortSignal = AbortSignal;
    exports.abortableFetch = abortableFetchDecorator;
  }
});

// node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js
var require_abortcontroller_ponyfill = __commonJS({
  "node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortSignal = exports.AbortController = void 0;
    var cjs_ponyfill_1 = require_cjs_ponyfill();
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var AbortController = typeof getGlobal().AbortController === "undefined" ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;
    exports.AbortController = AbortController;
    var AbortSignal = typeof getGlobal().AbortController === "undefined" ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;
    exports.AbortSignal = AbortSignal;
  }
});

// node_modules/abortable-promise-cache/esm/AggregateAbortController.js
var require_AggregateAbortController = __commonJS({
  "node_modules/abortable-promise-cache/esm/AggregateAbortController.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abortcontroller_ponyfill_1 = require_abortcontroller_ponyfill();
    var NullSignal = class {
    };
    var AggregateAbortController = class {
      constructor() {
        this.signals = /* @__PURE__ */ new Set();
        this.abortController = new abortcontroller_ponyfill_1.AbortController();
      }
      /**
       * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,
       *  will be treated as a null-signal, and this abortcontroller will no
       *  longer be abortable.
       */
      //@ts-ignore
      addSignal(signal = new NullSignal()) {
        if (this.signal.aborted) {
          throw new Error("cannot add a signal, already aborted!");
        }
        this.signals.add(signal);
        if (signal.aborted) {
          this.handleAborted(signal);
        } else if (typeof signal.addEventListener === "function") {
          signal.addEventListener("abort", () => {
            this.handleAborted(signal);
          });
        }
      }
      handleAborted(signal) {
        this.signals.delete(signal);
        if (this.signals.size === 0) {
          this.abortController.abort();
        }
      }
      get signal() {
        return this.abortController.signal;
      }
      abort() {
        this.abortController.abort();
      }
    };
    exports.default = AggregateAbortController;
  }
});

// node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js
var require_AggregateStatusReporter = __commonJS({
  "node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AggregateStatusReporter = class {
      constructor() {
        this.callbacks = /* @__PURE__ */ new Set();
      }
      addCallback(callback = () => {
      }) {
        this.callbacks.add(callback);
        callback(this.currentMessage);
      }
      callback(message) {
        this.currentMessage = message;
        this.callbacks.forEach((elt) => {
          elt(message);
        });
      }
    };
    exports.default = AggregateStatusReporter;
  }
});

// node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js
var require_AbortablePromiseCache = __commonJS({
  "node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var abortcontroller_ponyfill_1 = require_abortcontroller_ponyfill();
    var AggregateAbortController_1 = __importDefault(require_AggregateAbortController());
    var AggregateStatusReporter_1 = __importDefault(require_AggregateStatusReporter());
    var AbortablePromiseCache = class {
      constructor({ fill, cache }) {
        if (typeof fill !== "function") {
          throw new TypeError("must pass a fill function");
        }
        if (typeof cache !== "object") {
          throw new TypeError("must pass a cache object");
        }
        if (typeof cache.get !== "function" || typeof cache.set !== "function" || typeof cache.delete !== "function") {
          throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");
        }
        this.cache = cache;
        this.fillCallback = fill;
      }
      static isAbortException(exception) {
        return (
          // DOMException
          exception.name === "AbortError" || // standard-ish non-DOM abort exception
          //@ts-ignore
          exception.code === "ERR_ABORTED" || // stringified DOMException
          exception.message === "AbortError: aborted" || // stringified standard-ish exception
          exception.message === "Error: aborted"
        );
      }
      evict(key, entry) {
        if (this.cache.get(key) === entry) {
          this.cache.delete(key);
        }
      }
      fill(key, data, signal, statusCallback) {
        const aborter = new AggregateAbortController_1.default();
        const statusReporter = new AggregateStatusReporter_1.default();
        statusReporter.addCallback(statusCallback);
        const newEntry = {
          aborter,
          promise: this.fillCallback(data, aborter.signal, (message) => {
            statusReporter.callback(message);
          }),
          settled: false,
          statusReporter,
          get aborted() {
            return this.aborter.signal.aborted;
          }
        };
        newEntry.aborter.addSignal(signal);
        newEntry.aborter.signal.addEventListener("abort", () => {
          if (!newEntry.settled) {
            this.evict(key, newEntry);
          }
        });
        newEntry.promise.then(() => {
          newEntry.settled = true;
        }, () => {
          newEntry.settled = true;
          this.evict(key, newEntry);
        }).catch((e) => {
          console.error(e);
          throw e;
        });
        this.cache.set(key, newEntry);
      }
      static checkSinglePromise(promise, signal) {
        function checkForSingleAbort() {
          if (signal && signal.aborted) {
            throw Object.assign(new Error("aborted"), { code: "ERR_ABORTED" });
          }
        }
        return promise.then((result) => {
          checkForSingleAbort();
          return result;
        }, (error) => {
          checkForSingleAbort();
          throw error;
        });
      }
      has(key) {
        return this.cache.has(key);
      }
      /**
       * Callback for getting status of the pending async
       *
       * @callback statusCallback
       * @param {any} status, current status string or message object
       */
      /**
       * @param {any} key cache key to use for this request
       * @param {any} data data passed as the first argument to the fill callback
       * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request
       * @param {statusCallback} a callback to get the current status of a pending async operation
       */
      get(key, data, signal, statusCallback) {
        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {
          throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");
        }
        const cacheEntry = this.cache.get(key);
        if (cacheEntry) {
          if (cacheEntry.aborted && !cacheEntry.settled) {
            this.evict(key, cacheEntry);
            return this.get(key, data, signal, statusCallback);
          }
          if (cacheEntry.settled) {
            return cacheEntry.promise;
          }
          cacheEntry.aborter.addSignal(signal);
          cacheEntry.statusReporter.addCallback(statusCallback);
          return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);
        }
        this.fill(key, data, signal, statusCallback);
        return AbortablePromiseCache.checkSinglePromise(
          //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-
          //eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          this.cache.get(key).promise,
          signal
        );
      }
      /**
       * delete the given entry from the cache. if it exists and its fill request has
       * not yet settled, the fill will be signaled to abort.
       *
       * @param {any} key
       */
      delete(key) {
        const cachedEntry = this.cache.get(key);
        if (cachedEntry) {
          if (!cachedEntry.settled) {
            cachedEntry.aborter.abort();
          }
          this.cache.delete(key);
        }
      }
      /**
       * Clear all requests from the cache. Aborts any that have not settled.
       * @returns {number} count of entries deleted
       */
      clear() {
        const keyIter = this.cache.keys();
        let deleteCount = 0;
        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {
          this.delete(result.value);
          deleteCount += 1;
        }
        return deleteCount;
      }
    };
    exports.default = AbortablePromiseCache;
  }
});

// node_modules/abortable-promise-cache/esm/index.js
var require_esm = __commonJS({
  "node_modules/abortable-promise-cache/esm/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbortablePromiseCache_1 = __importDefault(require_AbortablePromiseCache());
    exports.default = AbortablePromiseCache_1.default;
  }
});

export {
  require_esm
};
//# sourceMappingURL=chunk-NI623UZ4.js.map
