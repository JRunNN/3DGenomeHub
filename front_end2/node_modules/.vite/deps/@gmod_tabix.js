import {
  require_esm
} from "./chunk-NI623UZ4.js";
import {
  unzip,
  unzipChunkSlice
} from "./chunk-6OABXZX4.js";
import {
  import_localFile
} from "./chunk-SCS3ED4A.js";
import {
  require_buffer
} from "./chunk-WVR4NYW2.js";
import {
  __commonJS,
  __toESM
} from "./chunk-JEXKZRFY.js";

// node_modules/@gmod/tabix/node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/@gmod/tabix/node_modules/quick-lru/index.js"(exports, module) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return this._size + oldCacheSize;
      }
    };
    module.exports = QuickLRU;
  }
});

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports, module) {
    module.exports = Long3;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long3(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long3.prototype.__isLong__;
    Object.defineProperty(Long3.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long3.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long3.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long3.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long3(lowBits, highBits, unsigned);
    }
    Long3.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long3.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long3.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long3.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long3.UZERO = UZERO;
    var ONE = fromInt(1);
    Long3.ONE = ONE;
    var UONE = fromInt(1, true);
    Long3.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long3.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long3.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long3.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long3.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long3.fromBytes = function fromBytes2(bytes, unsigned, le) {
      return le ? Long3.fromBytesLE(bytes, unsigned) : Long3.fromBytesBE(bytes, unsigned);
    };
    Long3.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long3(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long3.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long3(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// node_modules/@gmod/tabix/esm/tabixIndexedFile.js
var import_abortable_promise_cache = __toESM(require_esm());
var import_quick_lru = __toESM(require_quick_lru());
var import_buffer = __toESM(require_buffer());

// node_modules/@gmod/tabix/esm/util.js
function longToNumber(long) {
  if (long.greaterThan(Number.MAX_SAFE_INTEGER) || long.lessThan(Number.MIN_SAFE_INTEGER)) {
    throw new Error("integer overflow");
  }
  return long.toNumber();
}
var AbortError = class extends Error {
};
function checkAbortSignal(signal) {
  if (!signal) {
    return;
  }
  if (signal.aborted) {
    if (typeof DOMException !== "undefined") {
      throw new DOMException("aborted", "AbortError");
    } else {
      const e = new AbortError("aborted");
      e.code = "ERR_ABORTED";
      throw e;
    }
  }
}
function canMergeBlocks(chunk1, chunk2) {
  return chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65e3 && chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5e6;
}
function optimizeChunks(chunks, lowest) {
  const mergedChunks = [];
  let lastChunk = null;
  if (chunks.length === 0) {
    return chunks;
  }
  chunks.sort(function(c0, c1) {
    const dif = c0.minv.blockPosition - c1.minv.blockPosition;
    if (dif !== 0) {
      return dif;
    } else {
      return c0.minv.dataPosition - c1.minv.dataPosition;
    }
  });
  chunks.forEach((chunk) => {
    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {
      if (lastChunk === null) {
        mergedChunks.push(chunk);
        lastChunk = chunk;
      } else {
        if (canMergeBlocks(lastChunk, chunk)) {
          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {
            lastChunk.maxv = chunk.maxv;
          }
        } else {
          mergedChunks.push(chunk);
          lastChunk = chunk;
        }
      }
    }
  });
  return mergedChunks;
}

// node_modules/@gmod/tabix/esm/tbi.js
var import_long = __toESM(require_long());

// node_modules/@gmod/tabix/esm/virtualOffset.js
var VirtualOffset = class {
  constructor(blockPosition, dataPosition) {
    this.blockPosition = blockPosition;
    this.dataPosition = dataPosition;
  }
  toString() {
    return `${this.blockPosition}:${this.dataPosition}`;
  }
  compareTo(b) {
    return this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition;
  }
  static min(...args) {
    let min;
    let i = 0;
    for (; !min; i += 1) {
      min = args[i];
    }
    for (; i < args.length; i += 1) {
      if (min.compareTo(args[i]) > 0) {
        min = args[i];
      }
    }
    return min;
  }
};
function fromBytes(bytes, offset = 0, bigendian = false) {
  if (bigendian) {
    throw new Error("big-endian virtual file offsets not implemented");
  }
  return new VirtualOffset(bytes[offset + 7] * 1099511627776 + bytes[offset + 6] * 4294967296 + bytes[offset + 5] * 16777216 + bytes[offset + 4] * 65536 + bytes[offset + 3] * 256 + bytes[offset + 2], bytes[offset + 1] << 8 | bytes[offset]);
}

// node_modules/@gmod/tabix/esm/chunk.js
var Chunk = class {
  /**
   * @param {VirtualOffset} minv
   * @param {VirtualOffset} maxv
   * @param {number} bin
   * @param {number} [fetchedSize]
   */
  constructor(minv, maxv, bin, fetchedSize = void 0) {
    this.minv = minv;
    this.maxv = maxv;
    this.bin = bin;
    this._fetchedSize = fetchedSize;
  }
  toUniqueString() {
    return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;
  }
  toString() {
    return this.toUniqueString();
  }
  compareTo(b) {
    return this.minv.compareTo(b.minv) || this.maxv.compareTo(b.maxv) || this.bin - b.bin;
  }
  fetchedSize() {
    if (this._fetchedSize !== void 0) {
      return this._fetchedSize;
    }
    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;
  }
};

// node_modules/@gmod/tabix/esm/indexFile.js
var IndexFile = class {
  constructor({ filehandle, renameRefSeqs = (n) => n }) {
    this.filehandle = filehandle;
    this.renameRefSeq = renameRefSeqs;
  }
  async getMetadata(opts = {}) {
    const { indices, ...rest } = await this.parse(opts);
    return rest;
  }
  _findFirstData(currentFdl, virtualOffset) {
    if (currentFdl) {
      return currentFdl.compareTo(virtualOffset) > 0 ? virtualOffset : currentFdl;
    } else {
      return virtualOffset;
    }
  }
  async parse(opts = {}) {
    if (!this.parseP) {
      this.parseP = this._parse(opts).catch((e) => {
        this.parseP = void 0;
        throw e;
      });
    }
    return this.parseP;
  }
  async hasRefSeq(seqId, opts = {}) {
    return !!((await this.parse(opts)).indices[seqId] || {}).binIndex;
  }
};

// node_modules/@gmod/tabix/esm/tbi.js
var TBI_MAGIC = 21578324;
var TAD_LIDX_SHIFT = 14;
function reg2bins(beg, end) {
  beg += 1;
  end -= 1;
  return [
    [0, 0],
    [1 + (beg >> 26), 1 + (end >> 26)],
    [9 + (beg >> 23), 9 + (end >> 23)],
    [73 + (beg >> 20), 73 + (end >> 20)],
    [585 + (beg >> 17), 585 + (end >> 17)],
    [4681 + (beg >> 14), 4681 + (end >> 14)]
  ];
}
var TabixIndex = class extends IndexFile {
  async lineCount(refName, opts = {}) {
    const indexData = await this.parse(opts);
    if (!indexData) {
      return -1;
    }
    const refId = indexData.refNameToId[refName];
    const idx = indexData.indices[refId];
    if (!idx) {
      return -1;
    }
    const { stats } = indexData.indices[refId];
    if (stats) {
      return stats.lineCount;
    }
    return -1;
  }
  // fetch and parse the index
  async _parse(opts = {}) {
    const buf = await this.filehandle.readFile(opts);
    const bytes = await unzip(buf);
    checkAbortSignal(opts.signal);
    if (bytes.readUInt32LE(0) !== TBI_MAGIC) {
      throw new Error("Not a TBI file");
    }
    const refCount = bytes.readInt32LE(4);
    const formatFlags = bytes.readInt32LE(8);
    const coordinateType = formatFlags & 65536 ? "zero-based-half-open" : "1-based-closed";
    const formatOpts = {
      0: "generic",
      1: "SAM",
      2: "VCF"
    };
    const format = formatOpts[formatFlags & 15];
    if (!format) {
      throw new Error(`invalid Tabix preset format flags ${formatFlags}`);
    }
    const columnNumbers = {
      ref: bytes.readInt32LE(12),
      start: bytes.readInt32LE(16),
      end: bytes.readInt32LE(20)
    };
    const metaValue = bytes.readInt32LE(24);
    const depth = 5;
    const maxBinNumber = ((1 << (depth + 1) * 3) - 1) / 7;
    const maxRefLength = 2 ** (14 + depth * 3);
    const metaChar = metaValue ? String.fromCharCode(metaValue) : null;
    const skipLines = bytes.readInt32LE(28);
    const nameSectionLength = bytes.readInt32LE(32);
    const { refNameToId, refIdToName } = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));
    let currOffset = 36 + nameSectionLength;
    let firstDataLine;
    const indices = new Array(refCount).fill(0).map(() => {
      const binCount = bytes.readInt32LE(currOffset);
      currOffset += 4;
      const binIndex = {};
      let stats;
      for (let j = 0; j < binCount; j += 1) {
        const bin = bytes.readUInt32LE(currOffset);
        currOffset += 4;
        if (bin > maxBinNumber + 1) {
          throw new Error("tabix index contains too many bins, please use a CSI index");
        } else if (bin === maxBinNumber + 1) {
          const chunkCount = bytes.readInt32LE(currOffset);
          currOffset += 4;
          if (chunkCount === 2) {
            stats = this.parsePseudoBin(bytes, currOffset);
          }
          currOffset += 16 * chunkCount;
        } else {
          const chunkCount = bytes.readInt32LE(currOffset);
          currOffset += 4;
          const chunks = new Array(chunkCount);
          for (let k = 0; k < chunkCount; k += 1) {
            const u = fromBytes(bytes, currOffset);
            const v = fromBytes(bytes, currOffset + 8);
            currOffset += 16;
            firstDataLine = this._findFirstData(firstDataLine, u);
            chunks[k] = new Chunk(u, v, bin);
          }
          binIndex[bin] = chunks;
        }
      }
      const linearCount = bytes.readInt32LE(currOffset);
      currOffset += 4;
      const linearIndex = new Array(linearCount);
      for (let k = 0; k < linearCount; k += 1) {
        linearIndex[k] = fromBytes(bytes, currOffset);
        currOffset += 8;
        firstDataLine = this._findFirstData(firstDataLine, linearIndex[k]);
      }
      return { binIndex, linearIndex, stats };
    });
    return {
      indices,
      metaChar,
      maxBinNumber,
      maxRefLength,
      skipLines,
      firstDataLine,
      columnNumbers,
      coordinateType,
      format,
      refIdToName,
      refNameToId,
      maxBlockSize: 1 << 16
    };
  }
  parsePseudoBin(bytes, offset) {
    const lineCount = longToNumber(import_long.default.fromBytesLE(bytes.slice(offset + 16, offset + 24), true));
    return { lineCount };
  }
  _parseNameBytes(namesBytes) {
    let currRefId = 0;
    let currNameStart = 0;
    const refIdToName = [];
    const refNameToId = {};
    for (let i = 0; i < namesBytes.length; i += 1) {
      if (!namesBytes[i]) {
        if (currNameStart < i) {
          let refName = namesBytes.toString("utf8", currNameStart, i);
          refName = this.renameRefSeq(refName);
          refIdToName[currRefId] = refName;
          refNameToId[refName] = currRefId;
        }
        currNameStart = i + 1;
        currRefId += 1;
      }
    }
    return { refNameToId, refIdToName };
  }
  async blocksForRange(refName, min, max, opts = {}) {
    if (min < 0) {
      min = 0;
    }
    const indexData = await this.parse(opts);
    if (!indexData) {
      return [];
    }
    const refId = indexData.refNameToId[refName];
    const ba = indexData.indices[refId];
    if (!ba) {
      return [];
    }
    const minOffset = ba.linearIndex.length ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length ? ba.linearIndex.length - 1 : min >> TAD_LIDX_SHIFT] : new VirtualOffset(0, 0);
    if (!minOffset) {
      console.warn("querying outside of possible tabix range");
    }
    const overlappingBins = reg2bins(min, max);
    const chunks = [];
    for (const [start, end] of overlappingBins) {
      for (let bin = start; bin <= end; bin++) {
        if (ba.binIndex[bin]) {
          const binChunks = ba.binIndex[bin];
          for (let c = 0; c < binChunks.length; ++c) {
            chunks.push(new Chunk(binChunks[c].minv, binChunks[c].maxv, bin));
          }
        }
      }
    }
    const nintv = ba.linearIndex.length;
    let lowest = null;
    const minLin = Math.min(min >> 14, nintv - 1);
    const maxLin = Math.min(max >> 14, nintv - 1);
    for (let i = minLin; i <= maxLin; ++i) {
      const vp = ba.linearIndex[i];
      if (vp) {
        if (!lowest || vp.compareTo(lowest) < 0) {
          lowest = vp;
        }
      }
    }
    return optimizeChunks(chunks, lowest);
  }
};

// node_modules/@gmod/tabix/esm/csi.js
var import_long2 = __toESM(require_long());
var CSI1_MAGIC = 21582659;
var CSI2_MAGIC = 38359875;
function lshift(num, bits) {
  return num * 2 ** bits;
}
function rshift(num, bits) {
  return Math.floor(num / 2 ** bits);
}
var CSI = class extends IndexFile {
  constructor(args) {
    super(args);
    this.maxBinNumber = 0;
    this.depth = 0;
    this.minShift = 0;
  }
  async lineCount(refName, opts = {}) {
    const indexData = await this.parse(opts);
    if (!indexData) {
      return -1;
    }
    const refId = indexData.refNameToId[refName];
    const idx = indexData.indices[refId];
    if (!idx) {
      return -1;
    }
    const { stats } = indexData.indices[refId];
    if (stats) {
      return stats.lineCount;
    }
    return -1;
  }
  async indexCov() {
    throw new Error("CSI indexes do not support indexcov");
  }
  parseAuxData(bytes, offset) {
    const formatFlags = bytes.readInt32LE(offset);
    const coordinateType = formatFlags & 65536 ? "zero-based-half-open" : "1-based-closed";
    const format = { 0: "generic", 1: "SAM", 2: "VCF" }[formatFlags & 15];
    if (!format) {
      throw new Error(`invalid Tabix preset format flags ${formatFlags}`);
    }
    const columnNumbers = {
      ref: bytes.readInt32LE(offset + 4),
      start: bytes.readInt32LE(offset + 8),
      end: bytes.readInt32LE(offset + 12)
    };
    const metaValue = bytes.readInt32LE(offset + 16);
    const metaChar = metaValue ? String.fromCharCode(metaValue) : null;
    const skipLines = bytes.readInt32LE(offset + 20);
    const nameSectionLength = bytes.readInt32LE(offset + 24);
    const { refIdToName, refNameToId } = this._parseNameBytes(bytes.slice(offset + 28, offset + 28 + nameSectionLength));
    return {
      refIdToName,
      refNameToId,
      skipLines,
      metaChar,
      columnNumbers,
      format,
      coordinateType
    };
  }
  _parseNameBytes(namesBytes) {
    let currRefId = 0;
    let currNameStart = 0;
    const refIdToName = [];
    const refNameToId = {};
    for (let i = 0; i < namesBytes.length; i += 1) {
      if (!namesBytes[i]) {
        if (currNameStart < i) {
          let refName = namesBytes.toString("utf8", currNameStart, i);
          refName = this.renameRefSeq(refName);
          refIdToName[currRefId] = refName;
          refNameToId[refName] = currRefId;
        }
        currNameStart = i + 1;
        currRefId += 1;
      }
    }
    return { refNameToId, refIdToName };
  }
  // fetch and parse the index
  async _parse(opts = {}) {
    const bytes = await unzip(await this.filehandle.readFile(opts));
    let csiVersion;
    if (bytes.readUInt32LE(0) === CSI1_MAGIC) {
      csiVersion = 1;
    } else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {
      csiVersion = 2;
    } else {
      throw new Error("Not a CSI file");
    }
    this.minShift = bytes.readInt32LE(4);
    this.depth = bytes.readInt32LE(8);
    this.maxBinNumber = ((1 << (this.depth + 1) * 3) - 1) / 7;
    const maxRefLength = 2 ** (this.minShift + this.depth * 3);
    const auxLength = bytes.readInt32LE(12);
    const aux = auxLength && auxLength >= 30 ? this.parseAuxData(bytes, 16) : {
      refIdToName: [],
      refNameToId: {},
      metaChar: null,
      columnNumbers: { ref: 0, start: 1, end: 2 },
      coordinateType: "zero-based-half-open",
      format: "generic"
    };
    const refCount = bytes.readInt32LE(16 + auxLength);
    let firstDataLine;
    let currOffset = 16 + auxLength + 4;
    const indices = new Array(refCount).fill(0).map(() => {
      const binCount = bytes.readInt32LE(currOffset);
      currOffset += 4;
      const binIndex = {};
      let stats;
      for (let j = 0; j < binCount; j += 1) {
        const bin = bytes.readUInt32LE(currOffset);
        if (bin > this.maxBinNumber) {
          stats = this.parsePseudoBin(bytes, currOffset + 4);
          currOffset += 4 + 8 + 4 + 16 + 16;
        } else {
          const loffset = fromBytes(bytes, currOffset + 4);
          firstDataLine = this._findFirstData(firstDataLine, loffset);
          const chunkCount = bytes.readInt32LE(currOffset + 12);
          currOffset += 16;
          const chunks = new Array(chunkCount);
          for (let k = 0; k < chunkCount; k += 1) {
            const u = fromBytes(bytes, currOffset);
            const v = fromBytes(bytes, currOffset + 8);
            currOffset += 16;
            chunks[k] = new Chunk(u, v, bin);
          }
          binIndex[bin] = chunks;
        }
      }
      return { binIndex, stats };
    });
    return {
      ...aux,
      csi: true,
      refCount,
      maxBlockSize: 1 << 16,
      firstDataLine,
      csiVersion,
      indices,
      depth: this.depth,
      maxBinNumber: this.maxBinNumber,
      maxRefLength
    };
  }
  parsePseudoBin(bytes, offset) {
    const lineCount = longToNumber(import_long2.default.fromBytesLE(bytes.slice(offset + 28, offset + 36), true));
    return { lineCount };
  }
  async blocksForRange(refName, min, max, opts = {}) {
    if (min < 0) {
      min = 0;
    }
    const indexData = await this.parse(opts);
    if (!indexData) {
      return [];
    }
    const refId = indexData.refNameToId[refName];
    const ba = indexData.indices[refId];
    if (!ba) {
      return [];
    }
    const overlappingBins = this.reg2bins(min, max);
    const chunks = [];
    for (const [start, end] of overlappingBins) {
      for (let bin = start; bin <= end; bin++) {
        if (ba.binIndex[bin]) {
          const binChunks = ba.binIndex[bin];
          for (let c = 0; c < binChunks.length; ++c) {
            chunks.push(new Chunk(binChunks[c].minv, binChunks[c].maxv, bin));
          }
        }
      }
    }
    return optimizeChunks(chunks, new VirtualOffset(0, 0));
  }
  /**
   * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
   */
  reg2bins(beg, end) {
    beg -= 1;
    if (beg < 1) {
      beg = 1;
    }
    if (end > 2 ** 50) {
      end = 2 ** 34;
    }
    end -= 1;
    let l = 0;
    let t = 0;
    let s = this.minShift + this.depth * 3;
    const bins = [];
    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {
      const b = t + rshift(beg, s);
      const e = t + rshift(end, s);
      if (e - b + bins.length > this.maxBinNumber) {
        throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);
      }
      bins.push([b, e]);
    }
    return bins;
  }
};

// node_modules/@gmod/tabix/esm/tabixIndexedFile.js
var decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8") : void 0;
function timeout(time) {
  return new Promise((resolve) => setTimeout(resolve, time));
}
var TabixIndexedFile = class {
  /**
   * @param {object} args
   * @param {string} [args.path]
   * @param {filehandle} [args.filehandle]
   * @param {string} [args.tbiPath]
   * @param {filehandle} [args.tbiFilehandle]
   * @param {string} [args.csiPath]
   * @param {filehandle} [args.csiFilehandle]
   * @param {number} [args.yieldTime] yield to main thread after N milliseconds if reading features is taking a long time to avoid hanging main thread
   * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform
   * reference sequence names for the purpose of indexing and querying. note that the data that is returned is
   * not altered, just the names of the reference sequences that are used for querying.
   */
  constructor({ path, filehandle, tbiPath, tbiFilehandle, csiPath, csiFilehandle, yieldTime = 500, chunkSizeLimit = 5e7, renameRefSeqs = (n) => n, chunkCacheSize = 5 * 2 ** 20 }) {
    if (filehandle) {
      this.filehandle = filehandle;
    } else if (path) {
      this.filehandle = new import_localFile.default(path);
    } else {
      throw new TypeError("must provide either filehandle or path");
    }
    if (tbiFilehandle) {
      this.index = new TabixIndex({
        filehandle: tbiFilehandle,
        renameRefSeqs
      });
    } else if (csiFilehandle) {
      this.index = new CSI({
        filehandle: csiFilehandle,
        renameRefSeqs
      });
    } else if (tbiPath) {
      this.index = new TabixIndex({
        filehandle: new import_localFile.default(tbiPath),
        renameRefSeqs
      });
    } else if (csiPath) {
      this.index = new CSI({
        filehandle: new import_localFile.default(csiPath),
        renameRefSeqs
      });
    } else if (path) {
      this.index = new TabixIndex({
        filehandle: new import_localFile.default(`${path}.tbi`),
        renameRefSeqs
      });
    } else {
      throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath");
    }
    this.chunkSizeLimit = chunkSizeLimit;
    this.renameRefSeq = renameRefSeqs;
    this.yieldTime = yieldTime;
    this.chunkCache = new import_abortable_promise_cache.default({
      cache: new import_quick_lru.default({ maxSize: Math.floor(chunkCacheSize / (1 << 16)) }),
      fill: (args, signal) => this.readChunk(args, { signal })
    });
  }
  /**
   * @param refName name of the reference sequence
   * @param start start of the region (in 0-based half-open coordinates)
   * @param end end of the region (in 0-based half-open coordinates)
   * @param opts callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc
   * @returns promise that is resolved when the whole read is finished, rejected on error
   */
  async getLines(refName, start, end, opts) {
    let signal;
    let options = {};
    let callback;
    if (typeof opts === "undefined") {
      throw new TypeError("line callback must be provided");
    }
    if (typeof opts === "function") {
      callback = opts;
    } else {
      options = opts;
      callback = opts.lineCallback;
    }
    if (refName === void 0) {
      throw new TypeError("must provide a reference sequence name");
    }
    if (!callback) {
      throw new TypeError("line callback must be provided");
    }
    const metadata = await this.index.getMetadata(options);
    checkAbortSignal(signal);
    if (!start) {
      start = 0;
    }
    if (!end) {
      end = metadata.maxRefLength;
    }
    if (!(start <= end)) {
      throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");
    }
    if (start === end) {
      return;
    }
    const chunks = await this.index.blocksForRange(refName, start, end, options);
    checkAbortSignal(signal);
    for (let i = 0; i < chunks.length; i += 1) {
      const size = chunks[i].fetchedSize();
      if (size > this.chunkSizeLimit) {
        throw new Error(`Too much data. Chunk size ${size.toLocaleString()} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit.toLocaleString()}.`);
      }
    }
    let last = Date.now();
    for (let chunkNum = 0; chunkNum < chunks.length; chunkNum += 1) {
      let previousStartCoordinate;
      const c = chunks[chunkNum];
      const { buffer, cpositions, dpositions } = await this.chunkCache.get(c.toString(), c);
      checkAbortSignal(signal);
      let blockStart = 0;
      let pos = 0;
      while (blockStart < buffer.length) {
        const n = buffer.indexOf("\n", blockStart);
        if (n === -1) {
          break;
        }
        const b = buffer.slice(blockStart, n);
        const line = (decoder === null || decoder === void 0 ? void 0 : decoder.decode(b)) || b.toString();
        if (dpositions) {
          while (blockStart + c.minv.dataPosition >= dpositions[pos++]) {
          }
          pos--;
        }
        const { startCoordinate, overlaps } = this.checkLine(metadata, refName, start, end, line);
        if (previousStartCoordinate !== void 0 && startCoordinate !== void 0 && previousStartCoordinate > startCoordinate) {
          throw new Error(`Lines not sorted by start coordinate (${previousStartCoordinate} > ${startCoordinate}), this file is not usable with Tabix.`);
        }
        previousStartCoordinate = startCoordinate;
        if (overlaps) {
          callback(
            line.trim(),
            // cpositions[pos] refers to actual file offset of a bgzip block boundaries
            //
            // we multiply by (1 <<8) in order to make sure each block has a "unique"
            // address space so that data in that block could never overlap
            //
            // then the blockStart-dpositions is an uncompressed file offset from
            // that bgzip block boundary, and since the cpositions are multiplied by
            // (1 << 8) these uncompressed offsets get a unique space
            cpositions[pos] * (1 << 8) + (blockStart - dpositions[pos]) + c.minv.dataPosition + 1
          );
        } else if (startCoordinate !== void 0 && startCoordinate >= end) {
          return;
        }
        if (this.yieldTime && last - Date.now() > this.yieldTime) {
          last = Date.now();
          checkAbortSignal(signal);
          await timeout(1);
        }
        blockStart = n + 1;
      }
    }
  }
  async getMetadata(opts = {}) {
    return this.index.getMetadata(opts);
  }
  /**
   * get a buffer containing the "header" region of
   * the file, which are the bytes up to the first
   * non-meta line
   */
  async getHeaderBuffer(opts = {}) {
    const { firstDataLine, metaChar, maxBlockSize } = await this.getMetadata(opts);
    checkAbortSignal(opts.signal);
    const maxFetch = ((firstDataLine === null || firstDataLine === void 0 ? void 0 : firstDataLine.blockPosition) || 0) + maxBlockSize;
    let bytes = await this._readRegion(0, maxFetch, opts);
    checkAbortSignal(opts.signal);
    try {
      bytes = await unzip(bytes);
    } catch (e) {
      console.error(e);
      throw new Error(
        //@ts-ignore
        `error decompressing block ${e.code} at 0 (length ${maxFetch}) ${e}`
      );
    }
    if (metaChar) {
      let lastNewline = -1;
      const newlineByte = "\n".charCodeAt(0);
      const metaByte = metaChar.charCodeAt(0);
      for (let i = 0; i < bytes.length; i += 1) {
        if (i === lastNewline + 1 && bytes[i] !== metaByte) {
          break;
        }
        if (bytes[i] === newlineByte) {
          lastNewline = i;
        }
      }
      bytes = bytes.slice(0, lastNewline + 1);
    }
    return bytes;
  }
  /**
   * get a string containing the "header" region of the
   * file, is the portion up to the first non-meta line
   *
   * @returns {Promise} for a string
   */
  async getHeader(opts = {}) {
    const bytes = await this.getHeaderBuffer(opts);
    return bytes.toString("utf8");
  }
  /**
   * get an array of reference sequence names, in the order in which
   * they occur in the file. reference sequence renaming is not applied
   * to these names.
   */
  async getReferenceSequenceNames(opts = {}) {
    const metadata = await this.getMetadata(opts);
    return metadata.refIdToName;
  }
  /**
   * @param {object} metadata metadata object from the parsed index,
   * containing columnNumbers, metaChar, and format
   * @param {string} regionRefName
   * @param {number} regionStart region start coordinate (0-based-half-open)
   * @param {number} regionEnd region end coordinate (0-based-half-open)
   * @param {array[string]} line
   * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,
   * true if line is a data line that overlaps the given region
   */
  checkLine(metadata, regionRefName, regionStart, regionEnd, line) {
    const { columnNumbers, metaChar, coordinateType, format } = metadata;
    if (line.charAt(0) === metaChar) {
      return { overlaps: false };
    }
    let { ref, start, end } = columnNumbers;
    if (!ref) {
      ref = 0;
    }
    if (!start) {
      start = 0;
    }
    if (!end) {
      end = 0;
    }
    if (format === "VCF") {
      end = 8;
    }
    const maxColumn = Math.max(ref, start, end);
    let currentColumnNumber = 1;
    let currentColumnStart = 0;
    let refSeq = "";
    let startCoordinate = -Infinity;
    for (let i = 0; i < line.length + 1; i += 1) {
      if (line[i] === "	" || i === line.length) {
        if (currentColumnNumber === ref) {
          if (this.renameRefSeq(line.slice(currentColumnStart, i)) !== regionRefName) {
            return { overlaps: false };
          }
        } else if (currentColumnNumber === start) {
          startCoordinate = parseInt(line.slice(currentColumnStart, i), 10);
          if (coordinateType === "1-based-closed") {
            startCoordinate -= 1;
          }
          if (startCoordinate >= regionEnd) {
            return { startCoordinate, overlaps: false };
          }
          if (end === 0 || end === start) {
            if (startCoordinate + 1 <= regionStart) {
              return { startCoordinate, overlaps: false };
            }
          }
        } else if (format === "VCF" && currentColumnNumber === 4) {
          refSeq = line.slice(currentColumnStart, i);
        } else if (currentColumnNumber === end) {
          let endCoordinate;
          if (format === "VCF") {
            endCoordinate = this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i));
          } else {
            endCoordinate = parseInt(line.slice(currentColumnStart, i), 10);
          }
          if (endCoordinate <= regionStart) {
            return { overlaps: false };
          }
        }
        currentColumnStart = i + 1;
        currentColumnNumber += 1;
        if (currentColumnNumber > maxColumn) {
          break;
        }
      }
    }
    return { startCoordinate, overlaps: true };
  }
  _getVcfEnd(startCoordinate, refSeq, info) {
    let endCoordinate = startCoordinate + refSeq.length;
    const isTRA = info.indexOf("SVTYPE=TRA") !== -1;
    if (info[0] !== "." && !isTRA) {
      let prevChar = ";";
      for (let j = 0; j < info.length; j += 1) {
        if (prevChar === ";" && info.slice(j, j + 4) === "END=") {
          let valueEnd = info.indexOf(";", j);
          if (valueEnd === -1) {
            valueEnd = info.length;
          }
          endCoordinate = parseInt(info.slice(j + 4, valueEnd), 10);
          break;
        }
        prevChar = info[j];
      }
    } else if (isTRA) {
      return startCoordinate + 1;
    }
    return endCoordinate;
  }
  /**
   * return the approximate number of data lines in the given reference sequence
   * @param refSeq reference sequence name
   * @returns number of data lines present on that reference sequence
   */
  async lineCount(refName, opts = {}) {
    return this.index.lineCount(refName, opts);
  }
  async _readRegion(pos, size, opts = {}) {
    const b = import_buffer.Buffer.alloc(size);
    const { bytesRead, buffer } = await this.filehandle.read(b, 0, size, pos, opts);
    return buffer.slice(0, bytesRead);
  }
  /**
   * read and uncompress the data in a chunk (composed of one or more
   * contiguous bgzip blocks) of the file
   */
  async readChunk(c, opts = {}) {
    const data = await this._readRegion(c.minv.blockPosition, c.fetchedSize(), opts);
    try {
      return unzipChunkSlice(data, c);
    } catch (e) {
      throw new Error(`error decompressing c ${c.toString()} ${e}`);
    }
  }
};
export {
  CSI,
  TabixIndex as TBI,
  TabixIndexedFile
};
//# sourceMappingURL=@gmod_tabix.js.map
